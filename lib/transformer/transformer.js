// Generated by CoffeeScript 1.8.0
"use strict";

var path = require("path");
var fs = require("fs");
var xlsx = require("xlsx");
var dust = require("dustjs-linkedin");
var jpp = require("json-path-processor");
var pd = (require("pretty-data")).pd;
var bunyan = require("bunyan");
var log = bunyan.createLogger({name: "ace::transformer"});
var S = require("string");

var SCHEMA_FILENAME = "schema.json";
var SHEET_NAME = "PayPal";

var schemas = {};
var filenames = fs.readdirSync(path.join(__dirname, "schema"));
var i = 0;
var len = 0;
for (i = 0, len = filenames.length; i < len; i++) {
    var filename = filenames[i];
    var region = filename.replace(/\.json$/, "");
    schemas[region] = JSON.parse(fs.readFileSync(path.join(__dirname, "schema", filename)));
}

var templates = {};
filenames = fs.readdirSync(path.join(__dirname, "templates"));
for (i = 0, len = filenames.length; i < len; i++) {
    var filename = filenames[i];
    var region = filename.replace(/\.dust$/, "");
    templates[region] = (fs.readFileSync(path.join(__dirname, "templates", filename))).toString();
}

var loadExcelRecords = function (excelFilename) {
    var cell, key, records, sheet, value;
    records = {};    
    
    sheet = (xlsx.readFile(excelFilename)).Sheets[SHEET_NAME];    


    //why not sheet_to_json in https://www.npmjs.com/package/xlsx?
    for (key in sheet) {
        //console.log(key);
        value = sheet[key];
        cell = xlsx.utils.decode_cell(key);
        if (typeof cell.r === "number" && cell.r > 1 && typeof cell.c === "number") {
            (jpp(records)).set(cell.r + "." + cell.c, value.v, true);
        }
    }
    return records;
};

var parseExcelRecords = function (records, region) {
    var account, accounts, column, columns, data, element, jsonPath, row, schema, _k, _len2, errorAccounts;
    accounts = [];
    errorAccounts = [];
    schema = schemas[region];
        
    for (row in records) {
        
        columns = records[row];
        account = {};
        var errors = [];
        var errorAccount = {};        
        for (_k = 0, _len2 = schema.length; _k < _len2; _k++) {
            element = schema[_k];
            column = element.column;
            jsonPath = element.jsonPath;
            data = columns[column];
            
            var error = validate(data,element);

            if (!S(error).isEmpty()){                
                data = data + error; 
                var fieldName = S(element.description).replaceAll(' ', '').s;
                var obj =  {}
                obj[fieldName] = data;
                errors.push(obj);                
            } else{           
                if ((jsonPath !== null) && jsonPath !== "") {
                    (jpp(account)).set(jsonPath, data, true);
                }
            }
        }

        if (errors.length > 0){
            errorAccount["HotelName"]=columns[0];
            errorAccount["Errors"]=errors;
            errorAccounts.push(errorAccount);            
        }else{        
            accounts.push(account);
        }
    }
    return {accounts:accounts,errorAccounts:errorAccounts};
};

var validate = function(data,schemaColumn){
    
    var error = "";
    if (schemaColumn.required){
        if (S(data).isEmpty()){
            error += " - Required Field";
        }
    }

    if (schemaColumn.regex){
        //console.log(schemaColumn.regex);
        var patt = new RegExp(schemaColumn.regex);        
        if (!patt.test(data)){                        
            error += " - Does Not Match Format";
        }

    }
    return error;    
};

var renderXml = function (accounts, errorAccounts, region, done) {
    var account, template, _k, _len2, _results;
    if (accounts === null) {
        throw new Error();
    }

    template = templates[region];
    var handler = function (error, output) {
        if (error !== null) {
            throw new Error();
        } else {            
            return done(errorAccounts,pd.xml(output));
        }
    };

    dust.renderSource(template, {
        count: accounts.length,
        accounts: accounts        
    }, handler);
};

var transform = function (excelFilename, region, done) {
    var accounts;
    log.info("transform start");
    var all = parseExcelRecords(loadExcelRecords(excelFilename), region);
    log.info("parsing completed");
    renderXml(all.accounts, all.errorAccounts, region, done);
    log.info("transformation completed");
};

module.exports = {
    "transform": transform
};

